#!/usr/bin/python
# takes: genop.tab from erlang/otp
# produces: source of copypaste with all opcode implementations empty (copy manually)
import libgenop

libgenop.load()

print("""#pragma once
// Generated by codegen/vm_copypaste_impl.py

#include "g_process.h"
#include "bif/g_bif_misc.h"

namespace gluon {
namespace impl {

// Set of stuff we take from Process struct to keep running, this will be saved
// by loop runner on context switch or loop end
typedef struct {
  word_t *ip;   // code pointer
} runtime_ctx_t;

#define IMMED(var) if ((var).is_immed()) { proc->vm_resolve_immed(var); }
""")

# print headers
#for opcode in range(libgenop.MIN_OPCODE, libgenop.MAX_OPCODE+1):
#    op = libgenop.ops_by_code[opcode]
#    print("""  inline void opcode_%s(Process *proc); // opcode: %d""" % (op['name'], opcode))

# print implementations
for opcode in range(libgenop.MIN_OPCODE, libgenop.MAX_OPCODE+1):
    op = libgenop.ops_by_code[opcode]
    print("""  inline void opcode_%s(Process *proc, vm_runtime_ctx_t &ctx) { // opcode: %d
  }""" % (op['name'], opcode))

print
print("""} // ns impl
} // ns gluon
""")
print
